Q_t#include <omp.h>
#include "Resistive/Resistive.h"
using namespace std;
namespace PARSIFAL2{
  Resistive::Resistive(int setup,Geometry* geo, Readout* read):
    Setup(setup),
    geometry(geo),
    readout(read),
    PrintInfo(true),
    PrintNTuple(true)
  {
    r = new TRandom3();
    r->SetSeed(SEED);
    skip_resistive = NO_Resistive;

    sigma_res_diff=0.35;//si usa solo nel resistivo "smearing" e non quello reale
    
    //questi si usano davvero
    sigma0 = 0.001;//0.010;//10 Âµm;
    tau = 6; //18; //80ns era  5ns

    if(Get_Setup()==0){
      //triple-GEM setup has no resistive layer
      skip_resistive = true;
    }

    if(Get_Setup()!=0 && Get_Setup()!=1){
      cout<<"<>-<>  <>-<>  <>-<>  <>-<>  <>-<>"<<endl;
      cout<<"<>-<>      Resistive        <>-<>"<<endl;
      cout<<"<>-<>  Check the setup ID   <>-<>"<<endl;
      cout<<"<>-<>  <>-<>  <>-<>  <>-<>  <>-<>"<<endl;
    }
    if(Get_PrintInfo()){
      cout<<"----     New Resistive         ----"<<endl;
      cout<<"Setup configuration              : "<<Get_Setup()<<endl;
      cout<<"----------------------"<<endl;
    }
  };

  void Resistive::Resist(){
    const int n_strip_resistive = 7;
    if(skip_resistive) {
      #pragma omp parallel for
      for(int ich=0;ich<readout->Get_N_Channels();ich++){
	for(int it = 1; it < n_ns; it++) {
	  double raw_charge = readout->Get_Channel(ich)->Get_Histo_raw()->GetBinContent(it);
	  readout->Get_Channel(ich)->Get_Histo_cur_buffer()->AddBinContent(it+n_ns_buffer, raw_charge);
	}
      }
    }
    else{
      //loop on i-channel
      #pragma omp parallel for
      for(int ich=0;ich<readout->Get_N_Channels();ich++){
	if(readout->Get_Channel(ich)->Get_Histo_raw()->GetMaximum()==0) continue;
	//loop on i-time
	for(int it = 0; it < n_ns; it++) {
	  double raw_charge = readout->Get_Channel(ich)->Get_Histo_raw()->GetBinContent(it);
	  if(raw_charge==0) continue;
	  //loop on j-channel -> only neighbor channels
	  for(int jch=ich-n_strip_resistive; jch<ich+n_strip_resistive; jch++){
	    if(jch<0 || jch>readout->Get_N_Channels()) continue;
	    if(readout->Get_Channel(ich)->Get_Type()!=readout->Get_Channel(jch)->Get_Type()) continue;
	    double pitch = readout->Get_Channel(ich)->Get_Pitch();
	    //loop on j-time
	    for(int jt = 0; jt < n_ns; jt++) {
	      double res_charge = Q_t(pitch,jch-ich, it, jt, raw_charge);
	      readout->Get_Channel(jch)->Get_Histo_res()->AddBinContent(jt, res_charge);	    
	    }//end j-time
	  }//end j-channel
	}//end i-time
      }//end i-channel
      //Fill resistive current histogram
      #pragma omp parallel for
      for(int ich=0;ich<readout->Get_N_Channels();ich++){
	if(readout->Get_Channel(ich)->Get_Histo_res()->GetMaximum()==0) continue;
	for(int it = 1; it < n_ns; it++) {
	  double res_current = readout->Get_Channel(ich)->Get_Histo_res()->GetBinContent(it)-readout->Get_Channel(ich)->Get_Histo_res()->GetBinContent(it-1);
	  readout->Get_Channel(ich)->Get_Histo_cur_buffer()->AddBinContent(it+n_ns_buffer,res_current);
	}
      }//end i-channel
    }//end loop for resistive
    return;
  }

  vector<Secondary*> Resistive::Diffusion(vector<Secondary*> pre_resistive){
    vector<Secondary*> post_resistive;
    if(pre_resistive.empty()) return post_resistive;
    for(int isec=0;isec<pre_resistive.size();isec++){
      for(int iele=0;iele<pre_resistive.at(isec)->Get_GainedElectrons();iele++){
        int ID = pre_resistive.at(isec)->Get_PrimaryID();
        Position pos_initi = pre_resistive.at(isec)->Get_PositionFinal();
        Position pos_final = Get_FinalPosition(&pos_initi);
        Secondary *second = new Secondary(ID,pos_initi,pos_final);
        post_resistive.push_back(second);
      }
    }
    return post_resistive;
  };

  Position* Resistive::Get_FinalPosition(Position *pos_init){
    if(NO_Resistive) return pos_init;
    double xi = pos_init->Get_X();
    double yi = pos_init->Get_Y();
    double zi = pos_init->Get_Z();
    double ti = pos_init->Get_T();
    double xf = xi + Get_Diff_X(xi);
    double yf = yi + Get_Diff_Y(yi);
    double zf = zi + Get_Diff_Z(zi);
    double tf = ti + Get_Diff_T(ti);
    Position* pos= new Position(xf,yf,zf,tf);
    return pos;
  };

  double Resistive::Get_Diff_X(double x){
    double dx=0;
    cout<<"SET THIS TO ZERO"<<endl;
    dx = r->Gaus(0,sigma_res_diff);
    return dx;
  };
  double Resistive::Get_Diff_Y(double y){
    double dy=0;
    cout<<"SET THIS TO ZERO"<<endl;
    dy = r->Gaus(0,sigma_res_diff);
    return dy;
  };
  double Resistive::Get_Diff_Z(double z){
    double dz=0;
    return dz;
  };
  double Resistive::Get_Diff_T(double t){
    double dt=0;
    return dt;
  };
}
