#include <omp.h>
#include "main/Parsifal.h"
using namespace PARSIFAL2;

bool print_plot_all = 0;
bool print_plot_above_thr = 0;
bool print_plot_middle = 0; //also print waveform on file
bool print_plot_charge_above = 0;
bool plot_histo_Qt_APV = 1;

PARSIFAL::PARSIFAL() {
}

PARSIFAL::~PARSIFAL(){
  //Clean(); --> it crashes
  delete geo;
  delete D4;
  delete party;
  delete ionio;
  delete signal;
  delete recon;
  // ----------------------------
  //  delete tree; // do not try to delete it is automatically deleted wwith the file!
  delete file;
}

void PARSIFAL::Initialization_urtube(){
  cout<<"Ciao"<<endl;
  file = new TFile(name_outfile,"RECREATE");
  tree = new TTree("tree","tree");
  geo = RPhi(0.4, 90);
  //geo = RPhi(1.13, 90);
  //geo = RPhi(5, 90);
  D4 = new Position(party_DOCA,0,0,1000);
  party = new Particle(1, D4, 0, -0.0, geo);
  ionio = new Ionization(party,geo); //quando ho messo questa chiamata poi non mi usciva piu dalla sim dopo il bye bye
  signal = new Signal(2,0,Bfield,geo);
  recon = new Reconstruction(0,geo);
  event=0;
  Initialize_oFile();
  cout<<"Bye bye"<<endl;
  return;
}

void PARSIFAL::Initialization_tripleGEM(){
  cout<<"Ciao"<<endl;
  file = new TFile(name_outfile,"RECREATE");
  tree = new TTree("tree","tree");
  geo = Planar2D(0.65, 0.65, 5);
  D4 = new Position(0,0,0,0);
  party = new Particle(1, D4, party_angle_xz[0], -0.0, geo); 
  ionio = new Ionization(party,geo);
  signal = new Signal(0,0,Bfield,geo); //apv
  //signal = new Signal(0,1,Bfield,geo); //tiger
  recon = new Reconstruction(0,geo);
  event=0;
  Initialize_oFile();
  return;
}

void PARSIFAL::Initialization_rwell(){
  cout<<"Ciao"<<endl;
  file = new TFile(name_outfile,"RECREATE");
  tree = new TTree("tree","tree");
  geo = Planar1D(0.4, 6);
  D4 = new Position(0,0,0,0);
  party = new Particle(2, D4, party_angle_xz[0], -0.0, geo);
  ionio = new Ionization(party,geo);
  signal = new Signal(1,0,Bfield,geo); //APV
  //signal = new Signal(1,1,Bfield,geo); //TIGER
  recon = new Reconstruction(1,geo);
  event=0;
  Initialize_oFile();
  return;
}


void PARSIFAL::Run(){
  TRandom3 *r = new TRandom3();
  TString outname_txt = GetOutfileName();
  outname_txt.Remove(outname_txt.Length() - 4);
  outname_txt+= "txt";
  std::ofstream file_txt(outname_txt);
  if (!file_txt) {
    std::cerr << "Errore nell'apertura del file!" << std::endl;
    return;
  }
  r->SetSeed(SEED); // CHECK
  for(event=0;event<nShots;event++){
  //for(event=0;event<1;event++){
    cout<<"Shot: "<<event<<endl;
    //  <<  Init  >>
    Clean();
    party->Get_Position()->Set_X(r->Rndm()*geo->Get_Pitch1());
    party->Get_Position()->Set_Y(r->Rndm()*geo->Get_Pitch2());
    party->Get_Position()->Set_T(r->Rndm()*0+50);
    if(geo->Get_Type()==2) {
      party->Get_Position()->Set_Z(-sqrt(pow(geo->Get_DriftTotal(),2)-pow(party->Get_Position()->Get_X(),2)));
    }
    ionio = new Ionization(party,geo);
    //  <<  Process  >>
    //Ionization
    primi     = ionio->PrimaryIonization();
    if(fast_simulation){   //Create the electrons, amplification, drift and readout without generating the objects
      channels = signal->Generate_Signal(primi); 
      //for(int i=0;i<channels.size();i++) cout<<i<<" "<<channels.at(i)->Get_N_electrons()<<endl;
    }
    else{ //This mode generates the intemediates objects
      //Create the electrons from the primary clusters
      secondary = ionio->SecondaryIonization(primi);
      //Amplification and drift to the anode
      secondary = signal->Gain(secondary);
      //Electron drift through the gas and the resistive laer
      electrons           = signal->Drift(secondary); //qua c'Ã¨ un errore di sostanza!! prima deriva e poi guadagno e non il contrario !!! Questo era vero per le GEM
      electrons_resistive = signal->Resist(electrons);
      //Readout
      signal->Integrate_Charge(); //serve ancora? -> lo rimuoverei visto che va li sotto
      channels  = signal->Read(electrons_resistive);
      signal->Integrate_Charge(); //serve ancora?
      //for(int i=0;i<channels.size();i++) if(channels.at(i)->Get_N_electrons()) cout<<i<<" "<<channels.at(i)->Get_N_electrons()<<endl;
    }
    tot_ele_gained = signal->Get_Total_Electron_Gained();
    //Reconstruction
    hit       = recon->Digitize(channels);
    cluster1d = recon->Clusterize(hit);
    //  <<  Terminate  >>                                                                                                                                                                                  
    if(hit.empty()) nhit = 0;
    else            nhit = hit.size();
    if(nhit)  ncluster1d = cluster1d.size();
    else      ncluster1d = 0;
    
    Write_oFile();

    // Print PDF with charge/current/electronics histograms
    if(print_plot_all){ // Print all the channels
      for(int i=0;i<channels.size();i++) {
        cout<<i<<" \t "<<channels.at(i)->Get_N_electrons()<<" #ele \t \t "<<(float)(channels.at(i)->Get_N_electrons()*1.6e-4)<<" fC \t \t "<<(float)(channels.at(i)->Get_Charge())<<" fC"<<endl;
	channels.at(i)->Print_Time(event);
      }
      Plot_PDF_Channels();
    }
    if(print_plot_middle){ //print the channel in the middle
      for(int i=0;i<channels.size();i++) {
	if(i!=(int)(geo->Get_NumberOfStrip1()/2.)) continue;
	cout<<i<<" \t "<<channels.at(i)->Get_N_electrons()<<" #ele \t \t "<<(float)(channels.at(i)->Get_N_electrons()*1.6e-4)<<" fC \t \t "<<(float)(channels.at(i)->Get_Charge())<<" fC"<<endl;
        channels.at(i)->Print_Time(event);
	for(int itime=0;itime<channels.at(i)->Get_Histo_cur()->GetNbinsX()-1;itime++){
	  file_txt<<channels.at(i)->Get_Histo_cur()->GetBinContent(itime+1);
	  if(itime<channels.at(i)->Get_Histo_cur()->GetNbinsX()-2) file_txt<<",";
	}
	file_txt<<endl;
      }
    }
    if(print_plot_charge_above){ //Print channels with charge above 0
      for(int i=0;i<channels.size();i++) {
        if(channels.at(i)->Get_Charge()<=0) continue;
	cout<<i<<" \t "<<channels.at(i)->Get_N_electrons()<<" #ele \t \t "<<(float)(channels.at(i)->Get_N_electrons()*1.6e-4)<<" fC \t \t "<<(float)(channels.at(i)->Get_Charge())<<" fC"<<endl;
        channels.at(i)->Print_Time(event);
      }
    }
    if(print_plot_above_thr){ // Print the channels of hits above thr
      for(int i=0;i<hit.size();i++) if(hit.at(i)->Get_Charge()>0) channels.at(hit.at(i)->Get_ChannelID())->Print_Time(event);
      Plot_PDF_Channels();
    }
    // Print PDF with channel time/charge distribution
    if(print_plot_all){
      Plot_PDF_Channels();
    }
    // Check memory
    //MemInfo_t info;
    //if((double) info.fMemUsed/info.fMemTotal > 0.9) {
    //cout << "TOO MUCH MEMORY USED! " << (double) info.fMemUsed/info.fMemTotal <<  endl;
    //break;
    //}
    //FreeMemory();
  }
  //FreeMemory();

  #pragma omp barrier
  
  channels = signal->Get_Channels();
  for(int i=0;i<channels.size();i++) {
    channels.at(i)->~ElectronicChannel();
  }
  delete r;
  return;
}


void PARSIFAL::Terminate(){
  cout<<"Terminate"<<endl;
  file->Write();
  file->Close();
  cout<<"---- Output file ----"<<endl;
  cout<<"File written: "<<name_outfile<<endl;
  return;
}

void PARSIFAL::Plot_PDF_Channels(){
  TCanvas *c = new TCanvas("ccc","ccc",1600,1600);
  c->Divide(3,3);
  c->cd(1);
  // Plot all the channels ID vs Q
  TGraph *g_channel_q = new TGraph(channel_ID.size(),&(channel_ID[0]),&(channel_charge[0]));
  g_channel_q->Draw("AP*");
  g_channel_q->GetXaxis()->SetTitle("Channel ID");
  g_channel_q->GetYaxis()->SetTitle("Channel Charge [fC]");
  c->cd(2);
  // Plot all the channels ID vs T
  TGraph *g_channel_t = new TGraph(channel_ID.size(),&(channel_ID[0]),&(channel_time[0]));
  g_channel_t->Draw("AP*");
  g_channel_t->GetXaxis()->SetTitle("Channel ID");
  g_channel_t->GetYaxis()->SetTitle("Channel Time [fC]");
  //empty
  c->cd(3);
  // Plot the channelds ID vs Q if above threshold
  vector<double> channel_ID_above_thr, channel_time_above_thr, channel_charge_above_thr;
  for(int iCh=0;iCh<channel_ID.size(); iCh++){
    if(channel_above_thr.at(iCh)){
      channel_ID_above_thr.push_back(channel_ID.at(iCh));
      channel_time_above_thr.push_back(channel_time.at(iCh));
      channel_charge_above_thr.push_back(channel_charge.at(iCh));
    }
  }
  c->cd(4);
  TGraph *g_channel_q_above_thr = new TGraph(channel_ID_above_thr.size(),&(channel_ID_above_thr[0]),&(channel_charge_above_thr[0]));
  g_channel_q_above_thr->Draw("AP*");
  g_channel_q_above_thr->GetXaxis()->SetTitle("Channel above thr ID");
  g_channel_q_above_thr->GetYaxis()->SetTitle("Channel above thr Charge [fC]");
  // Plot the channelds ID vs T if above threshold
  c->cd(5);
  TGraph *g_channel_t_above_thr = new TGraph(channel_ID_above_thr.size(),&(channel_ID_above_thr[0]),&(channel_time_above_thr[0]));
  g_channel_t_above_thr->Draw("AP*");
  g_channel_t_above_thr->GetXaxis()->SetTitle("Channel above thr ID");
  g_channel_t_above_thr->GetYaxis()->SetTitle("Channel above thr Time [ns]");
  // Plot the total induced current collected on the readout
  c->cd(7);
  TH1D *hh_time_raw = new TH1D("tot_raw","Total current raw",n_ns, 0,  n_ns);  //total raw signal induced by electrons
  for(int ich=0;ich<channels.size();ich++){
    for(int ins=0;ins<n_ns;ins++){
      hh_time_raw->AddBinContent(ins,channels.at(ich)->Get_Histo_raw()->GetBinContent(ins));
    }
  }
  hh_time_raw->Draw();
  // Plot the total charge integrated from the induced current
  c->cd(8);
  TH1D *hh_time_tot = new TH1D("tot_tot","Total Charge",n_ns, 0,  n_ns); //total charge integrated
  for(int ich=0;ich<channels.size();ich++){
    for(int ins=0;ins<n_ns;ins++){
      hh_time_tot->AddBinContent(ins,channels.at(ich)->Get_Histo_tot()->GetBinContent(ins));
    }
  }
  hh_time_tot->Draw();
  // Plot the total charge integrated after the charge dispersion effect (if should be equal to hh_time_tot)
  c->cd(9);
  TH1D *hh_time_res = new TH1D("tot_res","Total Resistive Charge",n_ns, 0,  n_ns); //total charge integrated after resistive
  for(int ich=0;ich<channels.size();ich++){
    for(int ins=0;ins<n_ns;ins++){
      hh_time_res->AddBinContent(ins,channels.at(ich)->Get_Histo_res()->GetBinContent(ins));
    }
  }
  hh_time_res->Draw();
  //print
  c->SaveAs(Form("pdf/Event_%i_Channels.pdf",event));
  c->SaveAs(Form("pdf/Event_%i_Channels.png",event));
  delete c;
};

void PARSIFAL::Clean(){
  nhit=0;
  ncluster1d=0;
  tot_ele_gained=0;
  primi.clear();
  secondary.clear();
  electrons.clear();
  electrons_resistive.clear();
  for(int i=0;i<channels.size();i++) channels.at(i)->Reset(); // CHECK not needed if I use the FreeMemory
  channels.clear();
  hit.clear();
  cluster1d.clear();
  primary_positionX.clear();
  primary_positionY.clear();
  primary_positionZ.clear();
  primary_positionT.clear();
  primary_secondary.clear();
  primary_secondary_gain.clear();
  primary_ID.clear();
  secondary_gain.clear();
  electron_positionX_initial.clear();
  electron_positionY_initial.clear();
  electron_positionZ_initial.clear();
  electron_positionPhi_initial.clear();
  electron_positionT_initial.clear();
  electron_positionX_final.clear();
  electron_positionY_final.clear();
  electron_positionZ_final.clear();
  electron_positionPhi_final.clear();
  electron_positionT_final.clear();
  electron_primary_ID.clear();
  electron_electronic_channel.clear();
  channel_ID.clear();
  channel_type.clear();
  channel_charge.clear();
  channel_time.clear();
  channel_dtime.clear();
  channel_above_thr.clear();
  channel_above_thr_E.clear();
  channel_above_thr_T.clear();
  channel_t_rising_raw.clear();
  channel_t_rising_E.clear();
  channel_t_rising_T.clear();
  channel_t_falling_raw.clear();
  channel_t_falling_E.clear();
  channel_t_falling_T.clear();
  channel_positionX.clear();
  channel_positionY.clear();
  channel_positionZ.clear();
  channel_positionPhi.clear();
  channel_n_electrons.clear();
  hit_ID.clear();
  hit_channelID.clear();
  hit_clusterID.clear();
  hit_type.clear();
  hit_charge.clear();
  hit_time.clear();
  hit_dtime.clear();
  hit_positionX.clear();
  hit_positionY.clear();
  cluster1d_ID.clear();
  cluster1d_type.clear();
  cluster1d_size.clear();
  cluster1d_charge.clear();
  cluster1d_time0.clear();
  cluster1d_timeF.clear();
  cluster1d_positionCC_X.clear();
  cluster1d_positionCC_Y.clear();
  cluster1d_positionTPC_X.clear();
  cluster1d_positionTPC_Y.clear();
  cluster1d_high_Q.clear();
  cluster1d_faster.clear();
  signal->Clean();
}

void PARSIFAL::FreeMemory() {
  if(primi.size()>0)               {for (vector<Primary*>::iterator itr = primi.begin();                 itr != primi.end();               itr++) { delete *itr; }}
  if(secondary.size()>0)           {for (vector<Secondary*>::iterator itr = secondary.begin();           itr != secondary.end();           itr++) { delete *itr; }}
  if(electrons.size()>0)           {for (vector<Secondary*>::iterator itr = electrons.begin();           itr != electrons.end();           itr++) { delete *itr; }}
  if(electrons_resistive.size()>0) {for (vector<Secondary*>::iterator itr = electrons_resistive.begin(); itr != electrons_resistive.end(); itr++) { delete *itr; }}
  if(hit.size()>0)                 {for (vector<Hit*>::iterator itr = hit.begin();                       itr != hit.end();                 itr++) { delete *itr; }}
  if(cluster1d.size()>0)           {for (vector<Cluster1D*>::iterator itr = cluster1d.begin();           itr != cluster1d.end();           itr++) { delete *itr; }}
}

void PARSIFAL::Initialize_oFile(){
  tree->Branch("event" ,&event  ,"event/I");  
  if(PrintNTuple_Geo){
    tree->Branch("geo_numview" ,&geo_numview  ,"geo_numview/I");
    tree->Branch("geo_pitch1"  ,&geo_pitch1   ,"geo_pitch1/D");
    tree->Branch("geo_pitch2"  ,&geo_pitch2   ,"geo_pitch2/D");
    tree->Branch("geo_driftgap",&geo_driftgap ,"geo_driftgap/D");
  }
  if(PrintNTuple_Party){
    tree->Branch("party_partID"   ,&party_partID  ,"party_partID/I");
    tree->Branch("party_angleXZ"  ,&party_angleXZ ,"party_angleXZ/D");
    tree->Branch("party_angleYZ"  ,&party_angleYZ ,"party_angleYZ/D");
    tree->Branch("party_primary"  ,&party_primary ,"party_primary/D");      
    tree->Branch("party_positionI", party_posI    ,"party_positionI[4]/D"); // Impact point of the ionizing particle
    tree->Branch("party_prob"     , party_prob    ,"party_prob[100]/D");    // Ionization probability
  }
  if(PrintNTuple_Ionio){
    tree->Branch("ionio_positionI", ionio_positionI ,"ionio_posI[4]/D");   // Initial position of the primary ionization 
    tree->Branch("ionio_positionF", ionio_positionF ,"ionio_posF[4]/D");   // Final  position of the primary ionization  -> Useless
    tree->Branch("ionio_primary"  ,&ionio_primary   ,"ionio_primary/I");   // Number of primary clusters
    tree->Branch("ionio_secondary",&ionio_secondary ,"ionio_secondary/I"); // Total number of electrons from ionization (Sum on every primary clusters)
  }
  if(PrintNTuple_Primary){
    tree->Branch("primary_positionX" , "vector<double>" ,&primary_positionX); // X position of the primary cluster
    tree->Branch("primary_positionY" , "vector<double>" ,&primary_positionY); // Y position of the primary cluster
    tree->Branch("primary_positionZ" , "vector<double>" ,&primary_positionZ); // Z position of the primary cluster
    tree->Branch("primary_positionT" , "vector<double>" ,&primary_positionT); // time the primary cluster
    tree->Branch("primary_secondary" , "vector<int>"    ,&primary_secondary); // Number of electron for each primary cluster
    tree->Branch("primary_ID"        , "vector<int>"    ,&primary_ID);
    tree->Branch("secondary_gain"    , "vector<int>"    ,&secondary_gain);    // Not used 
  }
  if(PrintNTuple_Secondary && !fast_simulation){
    tree->Branch("electron_positionX_initial"   , "vector<double>" ,&electron_positionX_initial);
    tree->Branch("electron_positionY_initial"   , "vector<double>" ,&electron_positionY_initial);
    tree->Branch("electron_positionZ_initial"   , "vector<double>" ,&electron_positionZ_initial);
    tree->Branch("electron_positionPhi_initial" , "vector<double>" ,&electron_positionPhi_initial);
    tree->Branch("electron_positionT_initial"   , "vector<double>" ,&electron_positionT_initial);
    tree->Branch("electron_positionX_final"     , "vector<double>" ,&electron_positionX_final);
    tree->Branch("electron_positionY_final"     , "vector<double>" ,&electron_positionY_final);
    tree->Branch("electron_positionZ_final"     , "vector<double>" ,&electron_positionZ_final);
    tree->Branch("electron_positionPhi_final"   , "vector<double>" ,&electron_positionPhi_final);
    tree->Branch("electron_positionT_final"     , "vector<double>" ,&electron_positionT_final);
    tree->Branch("electron_primary_ID"          , "vector<int>"    ,&electron_primary_ID);
    tree->Branch("electron_electronic_channel"  , "vector<int>"    ,&electron_electronic_channel);  
  }
  if(PrintNTuple_Channel){
    tree->Branch("channel_ID"           , "vector<double>" ,&channel_ID);  
    tree->Branch("channel_type"         , "vector<int>"    ,&channel_type);  
    tree->Branch("channel_charge"       , "vector<double>" ,&channel_charge);
    tree->Branch("channel_time"         , "vector<double>" ,&channel_time);
    //tree->Branch("channel_dtime"      , "vector<double>" ,&channel_dtime);
    tree->Branch("channel_above_thr"    , "vector<bool>"   ,&channel_above_thr);
    tree->Branch("channel_above_thr_E"  , "vector<bool>"   ,&channel_above_thr_E);
    tree->Branch("channel_above_thr_T"  , "vector<bool>"   ,&channel_above_thr_T);
    tree->Branch("channel_t_rising_raw" , "vector<double>" ,&channel_t_rising_raw);
    tree->Branch("channel_t_rising_E"   , "vector<double>" ,&channel_t_rising_E);
    tree->Branch("channel_t_rising_T"   , "vector<double>" ,&channel_t_rising_T);
    tree->Branch("channel_t_falling_raw", "vector<double>" ,&channel_t_falling_raw);
    tree->Branch("channel_t_falling_E"  , "vector<double>" ,&channel_t_falling_E);
    tree->Branch("channel_t_falling_T"  , "vector<double>" ,&channel_t_falling_T);
    tree->Branch("channel_positionX"    , "vector<double>" ,&channel_positionX);
    tree->Branch("channel_positionY"    , "vector<double>" ,&channel_positionY);
    tree->Branch("channel_positionZ"    , "vector<double>" ,&channel_positionZ);
    tree->Branch("channel_positionPhi"  , "vector<double>" ,&channel_positionPhi);
    tree->Branch("channel_n_electrons"  ,"vector<int>"     ,&channel_n_electrons);
  }
  if(PrintNTuple_Hit){
    tree->Branch("nhit"          , &nhit            ,"nhit/I");  
    tree->Branch("hit_ID"        , "vector<int>"    ,&hit_ID);  
    tree->Branch("hit_channelID" , "vector<int>"    ,&hit_channelID);
    tree->Branch("hit_clusterID" , "vector<int>"    ,&hit_clusterID);  
    tree->Branch("hit_type"      , "vector<int>"    ,&hit_type);  
    tree->Branch("hit_charge"    , "vector<double>" ,&hit_charge);
    tree->Branch("hit_time"      , "vector<double>" ,&hit_time);
    tree->Branch("hit_dtime"     , "vector<double>" ,&hit_dtime);
    tree->Branch("hit_positionX" , "vector<double>" ,&hit_positionX);
    tree->Branch("hit_positionY" , "vector<double>" ,&hit_positionY);
  }  
  if(PrintNTuple_Cluster1d){
    tree->Branch("ncluster1d"              , &ncluster1d           ,"ncluster1d/I");  
    tree->Branch("cluster1d_ID"            , "vector<int>"         ,&cluster1d_ID);
    //tree->Branch("cluster1d_hitID"        , "vector<vector<int>>" ,&cluster1d_hitID);
    tree->Branch("cluster1d_type"          , "vector<int>"         ,&cluster1d_type);
    tree->Branch("cluster1d_size"          , "vector<int>"         ,&cluster1d_size);
    tree->Branch("cluster1d_charge"        , "vector<double>"      ,&cluster1d_charge);
    tree->Branch("cluster1d_time0"         , "vector<double>"      ,&cluster1d_time0);
    tree->Branch("cluster1d_timeF"         , "vector<double>"      ,&cluster1d_timeF);
    tree->Branch("cluster1d_positionCC_X"  , "vector<double>"      ,&cluster1d_positionCC_X);
    tree->Branch("cluster1d_positionCC_Y"  , "vector<double>"      ,&cluster1d_positionCC_Y);
    tree->Branch("cluster1d_positionTPC_X" , "vector<double>"      ,&cluster1d_positionTPC_X);
    tree->Branch("cluster1d_positionTPC_Y" , "vector<double>"      ,&cluster1d_positionTPC_Y);
    tree->Branch("cluster1d_high_Q"        , "vector<bool>"        ,&cluster1d_high_Q);
    tree->Branch("cluster1d_faster"        , "vector<bool>"        ,&cluster1d_faster);

  }
  if(PrintNTuple_General){
    tree->Branch("tot_electron_gained"    , &tot_ele_gained        ,"tot_electron_gained/I"); // total electron collected on the readout
  }

  if(plot_histo_Qt_APV){
    int hit_q_min = 0;
    int hit_q_step = 10;
    int hit_q_max = 80;
    for(int iq=0; iq<hit_q_max/hit_q_step; iq++){
      TH1F *histo_dummy_hit_qt = new TH1F (Form("apv_Qi_%i",iq),Form("Q>%i & Q<%i;Time [ns];Voltage [fC]",hit_q_min+iq*hit_q_step,hit_q_min+(iq+1)*hit_q_step),timebin_APV,0,timebin_APV*timestep_APV);
      histo_hit_Qt_APV.push_back(histo_dummy_hit_qt);
    }
    signal->Set_APV_Plot_Hit(histo_hit_Qt_APV);
  }
  
  return;  
}

void PARSIFAL::Write_oFile(){
  if(!Write_Output_File) return;
  //Output
  if(PrintNTuple_Geo){
    geo_numview  = geo->Get_NumberOfView();
    geo_pitch1   = geo->Get_Pitch1();
    geo_pitch2   = geo->Get_Pitch2();
    geo_driftgap = geo->Get_DriftGap();
  }
  if(PrintNTuple_Party){
    party_partID   = party->Get_ParticleID();
    party_angleXZ  = party->Get_AngleXZ();
    party_angleYZ  = party->Get_AngleYZ();
    party_primary  = party->Get_MeanPrimary();
    party_posI[0]  = party->Get_Position()->Get_X();
    party_posI[1]  = party->Get_Position()->Get_Y();
    party_posI[2]  = party->Get_Position()->Get_Z();
    party_posI[3]  = party->Get_Position()->Get_T();
    for(int i=0;i<100;i++) party_prob[i] = party->Get_ProbabilitySecondary(i);
  }
  if(PrintNTuple_Ionio){
    ionio_positionI[0] = ionio->Get_PositionInitial().Get_X();
    ionio_positionI[1] = ionio->Get_PositionInitial().Get_Y();
    ionio_positionI[2] = ionio->Get_PositionInitial().Get_Z();
    ionio_positionI[3] = ionio->Get_PositionInitial().Get_T();
    ionio_positionF[0] = ionio->Get_PositionFinal().Get_X();
    ionio_positionF[1] = ionio->Get_PositionFinal().Get_Y();
    ionio_positionF[2] = ionio->Get_PositionFinal().Get_Z();
    ionio_positionF[3] = ionio->Get_PositionFinal().Get_T();
    ionio_primary      = ionio->Get_TotalNumberOfPrimary();
    ionio_secondary    = ionio->Get_TotalNumberOfSecondary();
  }
  if(PrintNTuple_Secondary){
    if(secondary.empty()){
      secondary_gain.push_back(0);
    }
    else{
      for(int i=0;i<secondary.size();i++){
        secondary_gain.push_back(secondary.at(i)->Get_GainedElectrons());
      }
    }
  }
  if(PrintNTuple_Primary){
    if(primi.empty()){
      primary_positionX.push_back(-999);
      primary_positionY.push_back(-999);
      primary_positionZ.push_back(-999);
      primary_positionT.push_back(-999);
      primary_secondary.push_back(0);
      primary_ID.push_back(-1);
      secondary_gain.push_back(0);
    }
    else{
      for(int i=0;i<primi.size();i++){
	primary_positionX.push_back(primi.at(i)->Get_Position().Get_X());
	primary_positionY.push_back(primi.at(i)->Get_Position().Get_Y());
	primary_positionZ.push_back(primi.at(i)->Get_Position().Get_Z());
	primary_positionT.push_back(primi.at(i)->Get_Position().Get_T());
	primary_secondary.push_back(primi.at(i)->Get_NumberOfSecondary());
	primary_ID.push_back(i);
	if(secondary_gain.empty() || secondary_gain.size()) secondary_gain.push_back(0);
	else secondary_gain.push_back(secondary.at(i)->Get_GainedElectrons());
      }
    }
  }
  if(PrintNTuple_Secondary){  // CHECK in realta' gli oggetti electron_* sono prodotti solo da Drift
    if(electrons.empty()){
      electron_positionX_initial.push_back(-999);
      electron_positionY_initial.push_back(-999);
      electron_positionZ_initial.push_back(-999);
      electron_positionPhi_initial.push_back(-999);
      electron_positionT_initial.push_back(-999);
      electron_positionX_final.push_back(-999);
      electron_positionY_final.push_back(-999);
      electron_positionZ_final.push_back(-999);
      electron_positionPhi_final.push_back(-999);
      electron_positionT_final.push_back(-999);
      electron_primary_ID.push_back(.1);
      electron_electronic_channel.push_back(-1);
    }
    else{
      for(int i=0;i<electrons.size();i++){
	      electron_positionX_initial.push_back( electrons.at(i)->Get_PositionInitial().Get_X());
	      electron_positionY_initial.push_back( electrons.at(i)->Get_PositionInitial().Get_Y());
	      electron_positionZ_initial.push_back( electrons.at(i)->Get_PositionInitial().Get_Z());
	      electron_positionPhi_initial.push_back( electrons.at(i)->Get_PositionInitial().Get_Phi());
	      electron_positionT_initial.push_back( electrons.at(i)->Get_PositionInitial().Get_T());
	      electron_positionX_final.push_back(   electrons_resistive.at(i)->Get_PositionFinal().Get_X());
	      electron_positionY_final.push_back(   electrons_resistive.at(i)->Get_PositionFinal().Get_Y());
	      electron_positionZ_final.push_back(   electrons_resistive.at(i)->Get_PositionFinal().Get_Z());
	      electron_positionPhi_final.push_back(   electrons_resistive.at(i)->Get_PositionFinal().Get_Phi());
	      electron_positionT_final.push_back(   electrons_resistive.at(i)->Get_PositionFinal().Get_T());
	      electron_primary_ID.push_back(        electrons_resistive.at(i)->Get_PrimaryID());
	      electron_electronic_channel.push_back(electrons_resistive.at(i)->Get_ElectronicChannel());
        //cout<<i<<" "<<electrons.at(i)->Get_ElectronicChannel()<<" "<<endl;
      }
    }
  }
  if(PrintNTuple_Secondary){
    if(secondary.empty()){
      secondary_gain.push_back(0);
    }
    else{
      for(int i=0;i<secondary.size();i++){
	secondary_gain.push_back(secondary.at(i)->Get_GainedElectrons());      
      }
    }
  }
  if(PrintNTuple_Channel){
    if(channels.empty()){
      channel_ID.push_back(-1);
      channel_type.push_back(-1);
      channel_charge.push_back(-999);
      channel_time.push_back(-999);
      channel_above_thr.push_back(-999);
      channel_above_thr_E.push_back(-999);
      channel_above_thr_T.push_back(-999);
      channel_t_rising_raw.push_back(-999);
      channel_t_rising_E.push_back(-999);
      channel_t_rising_T.push_back(-999);
      channel_t_falling_raw.push_back(-999);
      channel_t_falling_E.push_back(-999);
      channel_t_falling_T.push_back(-999);
      //channel_dtime.push_back(-999);
      channel_positionX.push_back(-999);
      channel_positionY.push_back(-999);
      channel_positionPhi.push_back(-999);
      channel_n_electrons.push_back(0);
    }
    else{
      for(int i=0;i<channels.size();i++){
	channel_ID.push_back(channels.at(i)->Get_ChannelID());
	channel_type.push_back(channels.at(i)->Get_Type());
	channel_charge.push_back(channels.at(i)->Get_Charge());
	channel_time.push_back(channels.at(i)->Get_Time());
	//channel_dtime.push_back(channels.at(i)->Get_dTime());
	channel_above_thr.push_back(channels.at(i)->Get_AboveThr());
	channel_above_thr_E.push_back(channels.at(i)->Get_AboveThr_E());
        channel_above_thr_T.push_back(channels.at(i)->Get_AboveThr_T());
	channel_t_rising_raw.push_back(channels.at(i)->Get_t_rising_raw());
	channel_t_rising_E.push_back(channels.at(i)->Get_t_rising_E());
	channel_t_rising_T.push_back(channels.at(i)->Get_t_rising_T());
	channel_t_falling_raw.push_back(channels.at(i)->Get_t_falling_raw());
	channel_t_falling_E.push_back(channels.at(i)->Get_t_falling_E());
	channel_t_falling_T.push_back(channels.at(i)->Get_t_falling_T());
	channel_positionX.push_back(channels.at(i)->Get_Position().Get_X());
	channel_positionY.push_back(channels.at(i)->Get_Position().Get_Y());
	channel_positionZ.push_back(channels.at(i)->Get_Position().Get_Z());
	channel_positionPhi.push_back(channels.at(i)->Get_Position().Get_Phi());
	channel_n_electrons.push_back(channels.at(i)->Get_N_electrons());			     
	if(0){
	  file->cd();
	  TCanvas *cc1 = new TCanvas("cc1","cc1",800,600);
	  cc1->cd();
	  channels.at(i)->Get_Histo_raw()->Write();
	  cc1->SaveAs((TString)Form("delete/raw_%i_%i.root",event,i));
	  channels.at(i)->Get_Histo_apv()->Write();
	  cc1->SaveAs((TString)Form("delete/APV_%i_%i.root",event,i));
	  channels.at(i)->Get_Histo_int_apv()->Write();
	  cc1->SaveAs((TString)Form("delete/int_%i_%i.root",event,i));
	  channels.at(i)->Get_Histo_cap()->Write();
	  cc1->SaveAs((TString)Form("delete/cap_%i_%i.root",event,i));
	  delete cc1;
	}
      }
    }
  }
  if(PrintNTuple_Hit){
    if(hit.empty()){
      hit_ID.push_back(-1);
      hit_channelID.push_back(-1);
      hit_clusterID.push_back(-1);
      hit_type.push_back(-1);
      hit_charge.push_back(-999);
      hit_time.push_back(-999);
      // hit_dtime.push_back(-999);
      hit_positionX.push_back(-999);
      hit_positionY.push_back(-999);
    }
    else{
      for(int i=0;i<hit.size();i++){
	hit_ID.push_back(hit.at(i)->Get_HitID());
	hit_channelID.push_back(hit.at(i)->Get_ChannelID());
	hit_clusterID.push_back(hit.at(i)->Get_ClusterID());
	hit_type.push_back(hit.at(i)->Get_Type());
	hit_charge.push_back(hit.at(i)->Get_Charge());
	hit_time.push_back(hit.at(i)->Get_Time());
	hit_dtime.push_back(hit.at(i)->Get_dTime());
	hit_positionX.push_back(hit.at(i)->Get_Position().Get_X());
	hit_positionY.push_back(hit.at(i)->Get_Position().Get_Y());
      }    
    }
  }
  if(PrintNTuple_Cluster1d){
    if(cluster1d.empty()){
      cluster1d_ID.push_back(-1);
      cluster1d_type.push_back(-1);
      cluster1d_charge.push_back(-999);
      cluster1d_size.push_back(0);
      cluster1d_time0.push_back(-999);
      cluster1d_timeF.push_back(-999);
      cluster1d_positionCC_X.push_back(-999);
      cluster1d_positionCC_Y.push_back(-999);
      cluster1d_positionTPC_X.push_back(-999);
      cluster1d_positionTPC_Y.push_back(-999);
      cluster1d_high_Q.push_back(-1);
      cluster1d_faster.push_back(-1);
    }
    else{
      for(int i=0;i<cluster1d.size();i++){
	cluster1d_ID.push_back(cluster1d.at(i)->Get_ClusterID());
	cluster1d_type.push_back(cluster1d.at(i)->Get_Type());
	cluster1d_charge.push_back(cluster1d.at(i)->Get_Charge());
	cluster1d_size.push_back(cluster1d.at(i)->Get_Size());
	cluster1d_time0.push_back(cluster1d.at(i)->Get_Time0());
	cluster1d_timeF.push_back(cluster1d.at(i)->Get_TimeF());
	cluster1d_positionCC_X.push_back(cluster1d.at(i)->Get_Position_CC()->Get_X());
	cluster1d_positionCC_Y.push_back(cluster1d.at(i)->Get_Position_CC()->Get_Y());
	cluster1d_positionTPC_X.push_back(cluster1d.at(i)->Get_Position_TPC()->Get_X());
        cluster1d_positionTPC_Y.push_back(cluster1d.at(i)->Get_Position_TPC()->Get_Y());
	cluster1d_high_Q.push_back(cluster1d.at(i)->Get_High_Q());
	cluster1d_faster.push_back(cluster1d.at(i)->Get_Faster());
	//for(int j=0;j<cluster1d.at(i)->Get_Size();j++) cluster1d_hitID->at(i).push_back(cluster1d.at(i)->Get_HitID(j));
      }    
    }
  }
  tree->Fill();
  return;  
}
