#include <omp.h>
#include "Signal/Signal.h"
namespace PARSIFAL2{

  Signal::Signal(int setup, int electronics, bool MagField, Geometry *geo):
    setup(setup)
  {
    gain    = new DetectorGain(setup, Bfield);
    drift   = new ElectronDrift(setup, Bfield, geo);
    reado   = new Readout(setup,electronics,geo);
    resisto = new Resistive(setup,geo,reado);
  };
  Signal::~Signal(){
    delete gain;                                                                                                                        
    delete drift;
    delete resisto;
    delete reado;
  };

  vector<ElectronicChannel*> Signal::Generate_Signal(vector<Primary*> primary){ 
    int tot_ele = 0;
    int tot_gained = 0;
    int gain_speedup = 100;//1000; //3:1000 (top)  . 4:100 (nice). 5:10000 (approximate) . 6:100000 (no)
    if(NO_Gain) gain_speedup = 1;
    if(Fix_Gain) gain_speedup = FIX_GAIN;
    if(primary.empty()) return reado->Read();
    #pragma omp parallel for
    for(int iprimi=0;iprimi<primary.size();iprimi++){ //loop on the primary electron clusters 
      tot_ele = primary.at(iprimi)->Get_NumberOfSecondary();
      for(int iele=0; iele<primary.at(iprimi)->Get_NumberOfSecondary();iele++){ //lopp on the electrons inside the primary clusters
	int gain_this = gain->Get_Gain();

	// triple-GEM
	if(setup==0){
	  gain_this /= gain_speedup;
	  if(gain_this==0) gain_this=1;
	  tot_gained += gain_this*gain_speedup;
	  for(int igain=0; igain<gain_this;igain++){ //loop on the gained electrons via amplification
	    int view = reado->Define_View();
	    double z    = primary.at(iprimi)->Get_Position().Get_Z();
	    double time = primary.at(iprimi)->Get_Position().Get_T();
	    time += drift->Get_Drift_T(z);
	    time += resisto->Get_Diff_T(z);
	    if(view == Xview) {
	      double x = primary.at(iprimi)->Get_Position().Get_X();
	      x += drift->Get_Drift_X(z);
	      //x += resisto->Get_Diff_X(x); //old resistive approach
	      reado->Induce_on_channel(Xview,x,time,gain_speedup);
	    }
	    else if(view == Yview) {
	      double y = primary.at(iprimi)->Get_Position().Get_Y();
	      y += drift->Get_Drift_Y(z);
	      //y += resisto->Get_Diff_Y(y); //old resistive approach
	      reado->Induce_on_channel(Yview,y,time,gain_speedup);
	    }
	    else cout<<"Error in Signal::Generate_Signal --> no induction defined for this Readout type \n";
	  } //end loop on gained electrons after amplification	  
	} //end triple-GEM

	// µ-RWELL
	else if(setup==1){
	  int view = reado->Define_View();
	  double z    = primary.at(iprimi)->Get_Position().Get_Z();
	  double time = primary.at(iprimi)->Get_Position().Get_T();
	  time += drift->Get_Drift_T(z);
	  time += resisto->Get_Diff_T(z);
	  tot_gained += gain_this;
	  if(view == Xview) {
	    double x = primary.at(iprimi)->Get_Position().Get_X();
	    x += drift->Get_Drift_X(z);
	    //x += resisto->Get_Diff_X(x); //old resistive approach
	    reado->Induce_on_channel(Xview,x,time,gain_this);
	  }
	  else if(view == Yview) {
	    double y = primary.at(iprimi)->Get_Position().Get_Y();
	    y += drift->Get_Drift_Y(z);
	    //y += resisto->Get_Diff_Y(y); //old resistive approach
	    reado->Induce_on_channel(Yview,y,time,gain_this);
	  }
	  else cout<<"Error in Signal::Generate_Signal --> no induction defined for this Readout type \n";
	} //end µ-RWELL
	
      } //end loop on electrons in the primary cluster
    } //end loop on primary clusters
    Set_Total_Electron_Gained(tot_gained);
    reado->Integrate_Charge();
    resisto->Resist();
    return reado->Read();
  };

  vector<ElectronicChannel*> Signal::Get_Channels(){
    return reado->Get_Channels();
  }
  
}//end namespace
